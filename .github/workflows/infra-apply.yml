name: infra-apply

on:
  workflow_dispatch:
    inputs:
      project_path:
        description: 'App subdir (e.g., apps/my-react-app)'
        required: true
        type: string

permissions:
  id-token: write
  contents: write   # <-- needed for POST /dispatches

jobs:
  apply:
    runs-on: ubuntu-latest
    env:
      PROJECT_PATH: ${{ inputs.project_path }}
    steps:
      - uses: actions/checkout@v4

      - name: Sanity check project path
        shell: bash
        run: |
          set -euo pipefail
          test -d "${PROJECT_PATH}/infra" || { echo "::error::No infra dir at ${PROJECT_PATH}/infra"; exit 1; }

      - name: Normalize slug
        id: slug
        shell: bash
        run: |
          set -euo pipefail
          echo "slug=$(basename "$PROJECT_PATH")" >> "$GITHUB_OUTPUT"

      - name: AWS Credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GHA_ROLE_ARN }}
          aws-region:     ${{ secrets.AWS_REGION }}
          role-skip-session-tagging: true
          role-session-name: gha-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.x

      - name: Derive ENV
        id: env
        shell: bash
        run: |
          REF="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
          REF="${REF#refs/tags/}"
          ENV="${REF:-${GITHUB_REF_NAME}}"
          [[ "$ENV" == "main" ]] && ENV="prod"
          ENV="${ENV//\//-}"
          echo "env=$ENV" >> "$GITHUB_OUTPUT"

      - name: Write backend.hcl (use derived ENV)
        working-directory: ${{ env.PROJECT_PATH }}/infra
        shell: bash
        run: |
          set -euo pipefail
          ORG="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          ENV="${{ steps.env.outputs.env }}"
          APP="${{ env.PROJECT_PATH }}"
          cat > backend.hcl <<EOF
          bucket         = "${{ secrets.TFSTATE_BUCKET }}"
          key            = "repos/${ORG}/${REPO}/${ENV}/${APP}/terraform.tfstate"
          region         = "${{ secrets.AWS_REGION }}"
          dynamodb_table = "${{ secrets.TF_LOCK_TABLE }}"
          encrypt        = true
          EOF
          echo "Using state key: repos/${ORG}/${REPO}/${ENV}/${APP}/terraform.tfstate"

      - name: Terraform Init (remote backend)
        working-directory: ${{ env.PROJECT_PATH }}/infra
        run: terraform init -input=false -backend-config=backend.hcl -lock-timeout=3m

      - name: Terraform Apply
        working-directory: ${{ env.PROJECT_PATH }}/infra
        run: terraform apply -auto-approve -input=false -lock-timeout=3m -var "environment=${{ steps.env.outputs.env }}" -var-file=env/terraform.tfvars

      - name: Read TF outputs
        id: tfout
        working-directory: ${{ env.PROJECT_PATH }}/infra
        shell: bash
        run: |
          set -euo pipefail
          terraform output -json > tf_outputs.json || true
          BUCKET=$(jq -r '.bucket_name.value // empty' tf_outputs.json)
          DIST=$(jq -r '.cloudfront_distribution.value // empty' tf_outputs.json)
          DOMAIN=$(jq -r '.cloudfront_domain.value // empty' tf_outputs.json)
          echo "bucket=$BUCKET" >> "$GITHUB_OUTPUT"
          echo "dist=$DIST"     >> "$GITHUB_OUTPUT"
          echo "domain=$DOMAIN" >> "$GITHUB_OUTPUT"

      - name: Summarize outputs
        if: always()
        shell: bash
        run: |
          {
            echo "### 🌐 Deployed site"
            echo ""
            [[ -n "${{ steps.tfout.outputs.bucket }}" ]] && echo "- **Bucket:** \`${{ steps.tfout.outputs.bucket }}\`"
            [[ -n "${{ steps.tfout.outputs.dist }}"   ]] && echo "- **CloudFront ID:** \`${{ steps.tfout.outputs.dist }}\`"
            [[ -n "${{ steps.tfout.outputs.domain }}" ]] && echo "- **URL:** https://${{ steps.tfout.outputs.domain }}"
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Invalidate CloudFront
        if: ${{ success() && steps.tfout.outputs.dist != '' }}
        run: |
          aws cloudfront create-invalidation \
            --distribution-id "${{ steps.tfout.outputs.dist }}" \
            --paths "/*"

      - name: Trigger deploy-site
        if: ${{ success() && steps.tfout.outputs.domain != '' }}
        env:
          GH_TOKEN: ${{ github.token }}
          OWNER: ${{ github.repository_owner }}
          REPO:  ${{ github.event.repository.name }}
        shell: bash
        run: |
          set -euo pipefail
          payload=$(jq -n \
            --arg app    "${{ env.PROJECT_PATH }}" \
            --arg region "${{ secrets.AWS_REGION }}" \
            --arg bucket "${{ steps.tfout.outputs.bucket }}" \
            --arg dist   "${{ steps.tfout.outputs.dist }}" \
            --arg domain "${{ steps.tfout.outputs.domain }}" \
            --arg env    "${{ steps.env.outputs.env }}" \
            '{event_type:"deploy_site",
              client_payload:{project_path:$app, aws_region:$region,
                              bucket_name:$bucket, cloudfront_distribution:$dist,
                              cloudfront_domain:$domain, environment:$env}}')
          # capture HTTP status to surface errors clearly
          status=$(curl -sS -o /tmp/resp.json -w "%{http_code}" -X POST \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$OWNER/$REPO/dispatches" \
            -d "$payload")
          echo "Dispatch status: $status"
          [[ "$status" =~ ^2 ]] || { echo "::error::repository_dispatch failed"; cat /tmp/resp.json || true; exit 1; }
