name: deploy-site

on:
  repository_dispatch:
    types: [deploy_site]
  workflow_dispatch:
    inputs:
      project_path:
        description: 'App subdir (e.g., my-app)'
        required: false
        type: string

permissions:
  id-token: write
  contents: read

# Separate concurrency per dispatched app (or ref fallback)
concurrency:
  group: deploy-site-${{ github.workflow }}-${{ github.event.client_payload.project_path || github.ref || 'na' }}
  cancel-in-progress: false

jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      project_path: ${{ steps.detect.outputs.project_path }}
      aws_region:  ${{ steps.region.outputs.region }}
      app_url:     ${{ steps.url.outputs.app_url }}
      env_name:    ${{ steps.env.outputs.env_name }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - id: detect
        shell: bash
        run: |
          set -euo pipefail

          # 0) Manual run must provide project_path
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ -n "${{ inputs.project_path || '' }}" ]]; then
              echo "project_path=${{ inputs.project_path }}" >> "$GITHUB_OUTPUT"
              exit 0
            else
              echo "::error::Please provide 'project_path' when manually dispatching."
              exit 1
            fi
          fi

          # 1) repository_dispatch (preferred)
          if [[ "${{ github.event_name }}" == "repository_dispatch" && "${{ github.event.action }}" == "deploy_site" ]]; then
            echo "project_path=${{ github.event.client_payload.project_path }}" >> "$GITHUB_OUTPUT"
            echo "Detected app (dispatch): ${{ github.event.client_payload.project_path }}"
            exit 0
          fi

          echo "::error::Unsupported trigger for detect phase."
          exit 1

      - name: Read region (dispatch payload or tfvars)
        id: region
        shell: bash
        env:
          APP_DIR: ${{ steps.detect.outputs.project_path }}
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "repository_dispatch" && -n "${{ github.event.client_payload.aws_region }}" ]]; then
            echo "region=${{ github.event.client_payload.aws_region }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          FILE="$APP_DIR/infra/env/terraform.tfvars"
          REG=""
          if [[ -f "$FILE" ]]; then
            REG=$(awk -F= '/^\s*aws_region\s*=/{gsub(/[[:space:]"]/, "", $2); print $2}' "$FILE" | tail -n1)
          fi
          echo "region=${REG:-us-east-1}" >> "$GITHUB_OUTPUT"

      - name: Compute app URL
        id: url
        shell: bash
        run: |
          set -euo pipefail
          # Prefer explicit domain from dispatch payload
          if [[ "${{ github.event_name }}" == "repository_dispatch" && -n "${{ github.event.client_payload.cloudfront_domain }}" ]]; then
            echo "app_url=https://${{ github.event.client_payload.cloudfront_domain }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # Otherwise leave empty; we'll try to compute it in the deploy job
          echo "app_url=" >> "$GITHUB_OUTPUT"

      - name: Derive environment name
        id: env
        shell: bash
        run: |
          set -euo pipefail
          # 1) From repository_dispatch payload, if present
          if [[ "${{ github.event_name }}" == "repository_dispatch" && -n "${{ github.event.client_payload.environment }}" ]]; then
            echo "env_name=${{ github.event.client_payload.environment }}" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          # 2) Otherwise derive from ref (mainâ†’prod; else branch/tag name)
          REF="${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}"
          REF="${REF#refs/tags/}"
          ENV="${REF:-${GITHUB_REF_NAME}}"
          [[ "$ENV" == "main" ]] && ENV="prod"
          ENV="${ENV//\//-}"
          echo "env_name=$ENV" >> "$GITHUB_OUTPUT"

  deploy:
    needs: detect
    runs-on: ubuntu-latest
    # If you keep a GitHub Environment, ensure your OIDC trust allows environment:* (or the specific env).
    environment:
      name: ${{ needs.detect.outputs.env_name }}
      url:  ${{ needs.detect.outputs.app_url }}
    defaults:
      run:
        working-directory: ${{ needs.detect.outputs.project_path }}
    steps:
      - uses: actions/checkout@v4

      - uses: hashicorp/setup-terraform@v3

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_GHA_ROLE_ARN }}
          aws-region:     ${{ needs.detect.outputs.aws_region }}
          role-skip-session-tagging: true
          role-session-name: deploy-site-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Verify site payload exists
        shell: bash
        run: |
          set -euo pipefail
          test -d site || { echo "::error::No 'site/' directory in $PWD"; exit 2; }

      # --- NEW: write backend.hcl & init with backend when we need to read outputs ---
      - name: Write backend.hcl for outputs (when no payload)
        if: ${{ github.event_name != 'repository_dispatch' || (github.event.client_payload.bucket_name == '' && github.event.client_payload.cloudfront_distribution == '' && github.event.client_payload.cloudfront_domain == '') }}
        working-directory: ${{ needs.detect.outputs.project_path }}/infra
        shell: bash
        run: |
          set -euo pipefail
          ORG="${{ github.repository_owner }}"
          REPO="${{ github.event.repository.name }}"
          ENV="${{ needs.detect.outputs.env_name }}"
          APP="${{ needs.detect.outputs.project_path }}"
          cat > backend.hcl <<EOF
          bucket         = "${{ secrets.TFSTATE_BUCKET }}"
          key            = "repos/${ORG}/${REPO}/${ENV}/${APP}/terraform.tfstate"
          region         = "${{ needs.detect.outputs.aws_region }}"
          dynamodb_table = "${{ secrets.TF_LOCK_TABLE }}"
          encrypt        = true
          EOF
          echo "Using state key: repos/${ORG}/${REPO}/${ENV}/${APP}/terraform.tfstate"

      - name: Resolve bucket/dist/domain
        id: resolve
        working-directory: ${{ needs.detect.outputs.project_path }}/infra
        shell: bash
        run: |
          set -euo pipefail
          # Prefer repository_dispatch payload first
          BUCKET="${{ github.event.client_payload.bucket_name }}"
          DIST="${{ github.event.client_payload.cloudfront_distribution }}"
          DOMAIN="${{ github.event.client_payload.cloudfront_domain }}"

          if [[ -z "$BUCKET" || -z "$DIST" || -z "$DOMAIN" ]]; then
            # Initialize using backend to access remote state
            terraform init -input=false -backend-config=backend.hcl -lock-timeout=1m >/dev/null
            if ! terraform output -json > tf_outputs.json; then
              echo "::error::Could not read Terraform outputs from remote state. Provide repository_dispatch payload or ensure backend.hcl is correct."
              exit 2
            fi
            [[ -z "$BUCKET" ]] && BUCKET="$(jq -r '.bucket_name.value // empty' tf_outputs.json)"
            [[ -z "$DIST"   ]] && DIST="$(jq -r '.cloudfront_distribution.value // empty' tf_outputs.json)"
            [[ -z "$DOMAIN" ]] && DOMAIN="$(jq -r '.cloudfront_domain.value // empty' tf_outputs.json)"
          fi

          # Validate required fields
          [[ -z "$BUCKET" ]] && { echo "::error::No 'bucket_name' available (payload or state)."; exit 2; }
          echo "bucket=$BUCKET"  >> "$GITHUB_OUTPUT"
          echo "dist=$DIST"      >> "$GITHUB_OUTPUT"
          echo "domain=$DOMAIN"  >> "$GITHUB_OUTPUT"

      - name: Sync to S3
        run: aws s3 sync site/ "s3://${{ steps.resolve.outputs.bucket }}" --delete

      - name: Invalidate CloudFront (if available)
        shell: bash
        run: |
          set -euo pipefail
          DIST="${{ steps.resolve.outputs.dist }}"
          if [[ -n "$DIST" ]]; then
            aws cloudfront create-invalidation --distribution-id "$DIST" --paths "/*"
          else
            echo "No CloudFront distribution provided; skipping invalidation."
          fi

      - name: Ensure app URL (dist or TF output)
        id: ensure_url
        shell: bash
        run: |
          set -euo pipefail
          URL="${{ needs.detect.outputs.app_url }}"
          if [[ -z "$URL" ]]; then
            DOMAIN="${{ steps.resolve.outputs.domain }}"
            [[ -n "$DOMAIN" ]] && URL="https://${DOMAIN}"
          fi
          echo "app_url=$URL" >> "$GITHUB_OUTPUT"

      - name: Post deployment summary
        shell: bash
        run: |
          URL="${{ steps.ensure_url.outputs.app_url }}"
          {
            echo "## ðŸš€ Deployed static site"
            echo ""
            echo "- **App:** \`${{ needs.detect.outputs.project_path }}\`"
            echo "- **Region:** \`${{ needs.detect.outputs.aws_region }}\`"
            echo "- **Environment:** \`${{ needs.detect.outputs.env_name }}\`"
            if [[ -n "$URL" ]]; then
              echo "- **URL:** $URL"
              echo ""
              echo "[Open site]($URL)"
            else
              echo "> No site URL available."
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Show deploy info (dispatch payload)
        if: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.cloudfront_domain != '' }}
        shell: bash
        run: |
          APP="${{ github.event.client_payload.project_path }}"
          DOMAIN="${{ github.event.client_payload.cloudfront_domain }}"
          URL="https://${DOMAIN}"
          {
            echo "### ðŸš€ Deployed ${APP}"
            echo "- **URL:** [${URL}](${URL})"
            echo "- **Bucket:** \`${{ steps.resolve.outputs.bucket }}\`"
            echo "- **CloudFront ID:** \`${{ steps.resolve.outputs.dist }}\`"
          } >> "$GITHUB_STEP_SUMMARY"
